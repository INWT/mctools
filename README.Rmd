---
output:
  md_document:
    variant: markdown_github
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## The problem

Here is the problem we'd like to solve.

- We would like to have all warnings to be errors so that we can deal with them.
- We use third party packages which sometimes throw warnings. These warnings do
not make us happy, but they should not break in production. We know them and
want to except them.
- We use `parallel::mclapply` because we have some long running tasks and
realize `suppressWarnings` and `options(warn = 2)` do not work as expected in
parallel!

```{r}
options(warn = 0)
productionFunction <- function(x) {
  if (x == 1) suppressWarnings(warning("this may be okay"))
  ## just like *real* production code...
  else if (x == 2) stop("We should never end up in this branch...")
  else cbind(1:2, 1:3) # this is not okay and should be an error!
}

res <- parallel::mclapply(1:3, productionFunction, mc.cores = 2)
str(res)
options(warn = 2)
res1 <- parallel::mclapply(1:3, productionFunction, mc.cores = 2)
str(res1)
```

Do you see the problem? As soon as we change the options we do not even get a
result back as we would with *ordinary* errors. Terrible indeed! I hear you.
Fear not, there is a solution...

## The salvation

Use `mcMap` as a drop in replacement for `mclapply` if you need more control
over errors and warnings. Be aware that `mcMap` is a simple wrapper around
`mclapply` and is not a novel parallel computing interface.

```{r error=TRUE}
library(mctools)
options(warn = 2)
# capture warnings and process them as you wish:
mcMap(1:3, productionFunction, warnings = "return")
mcMap(1:3, productionFunction, warnings = "stop", warningsWhitelist = "multiple")
# or if we want to fail misserebly:
mcMap(1:3, productionFunction, warnings = "stop")
```

